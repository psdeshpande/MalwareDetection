import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Map;
import java.util.Scanner;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class malwareDetection {
	
	private static Graph createGraph(
		HashMap<String, ArrayList<String>> functionMap, funQueue queue, Graph graph) {
		
		boolean alreadyVertex=false;
		
		while(!queue.isEmpty()){
			String funName = queue.remove();
			ArrayList<String> callee = null;
			ArrayList<String> opcode = null;
			alreadyVertex=false;
			int length = 0;
			if(funName.substring(0, 3).equals("sub"))
			{
				ArrayList<String> funData = functionMap.get(funName);
				callee = new ArrayList<String>();
				opcode = new ArrayList<String>();
				/*Construct Vertex object from function data */
				for(int i=0;i<funData.size();i++)
				{
					String instruction = funData.get(i);
					String [] array = instruction.split(" ");
					if(array[0].equals("call"))
					{
						if(array[1].substring(0, 3).equals("sub") || (!array[1].substring(0, 3).equals("loc")))
						{
							callee.add(array[1]);
						}
					}
					if(!array[0].equals("length_"))
					{	
						opcode.add(array[0]);
					}	
					
					if(array[0].equals("length_"))
					{	
						length = Integer.parseInt(array[1]);
					}
				}
			}
			/*if vertex is already created i.e. it is exists in vertexList don't create it */
			int k=0;
			Vertex vertex = null;
			for(k=0;k<graph.vertexList.size();k++){
				if(graph.vertexList.get(k).function_name.equals(funName)){
					alreadyVertex=true;
					break;
				}
			}
			if(alreadyVertex==false){
			if(funName.substring(0, 3).equals("sub")){	
				vertex = new Vertex(funName,"local_routine",0,0,callee,opcode,length);
			}
			else
			{
				vertex = new Vertex(funName,"lib_routine",0,0,null,null,0);
			}
			vertex.enqueFlag=true;
			graph.addVertex(vertex);
			}
			else if(funName.substring(0, 3).equals("sub"))
			{
				graph.vertexList.get(k).callees=callee;
				graph.vertexList.get(k).opcode_seq=opcode;
				graph.vertexList.get(k).length=length;
			}
			
			else
			{
				graph.vertexList.get(k).callees=null;
				graph.vertexList.get(k).opcode_seq=null;
			}
			
			/*This part is executed only if it is subroutine function, as we don't
			  track calls from library function
			 */
			if(funName.substring(0, 3).equals("sub")){
			for(int i=0;i<callee.size();i++){
			
				/*Construct Vertex object from function data, again 
		 		 * these are local subroutine and not dynamic or 
		 		 * static function calls
		 		   */
			
				Vertex vertex1 = null;
				boolean alreadyVertex1=false;
				int l=0;
				for(l=0;l<graph.vertexList.size();l++){
					if(graph.vertexList.get(l).function_name.equals(callee.get(i))){
						alreadyVertex1=true;
						break;
					}
				}
				if(alreadyVertex1==false)
				{
					if(callee.get(i).substring(0, 3).equals("sub"))
					{
						vertex1 = new Vertex(callee.get(i),"local_routine",0,0,null,null,0);
					}
					else
					{
						vertex1 = new Vertex(callee.get(i),"lib_routine",0,0,null,null,0);
					}
					
					graph.addVertex(vertex1);
					if(vertex == null)
					{
						vertex = graph.vertexList.get(k);
						graph.addEdge(vertex, vertex1);
						vertex.outdegree++;
						vertex1.indegree++;
						
					}
					else
					{
						graph.addEdge(vertex, vertex1);
						vertex.outdegree++;
						vertex1.indegree++;
					}
					
				}
				
				else
				{
					if(vertex==null){
						vertex = graph.vertexList.get(k);
						graph.addEdge(vertex, graph.vertexList.get(l));
						vertex.outdegree++;
						graph.vertexList.get(l).indegree++;
					}
					else
					{
						graph.addEdge(vertex, graph.vertexList.get(l));
						vertex.outdegree++;
						graph.vertexList.get(l).indegree++;
					}
					
				}
				/*if there is edge between vertex and vertex1 
				 * increase weight, vertex outdegree and vertex1 indgree
				 * by 1
				 * */
				if(alreadyVertex1!=true){
				//if(vertex1.enqueFlag==false && alreadyVertex!=true){
					queue.insert(callee.get(i));
					vertex1.enqueFlag=true;
				}
			}
			}
			
			
		}
		
		
		return graph;
	}

	public static void main(String[] args) throws IOException {

		
		String funStart_regex = "sub_(\\w)+ proc near";
		Pattern start_pattern = Pattern.compile(funStart_regex);
		
		String funEnd_regex = "sub_(\\w)+ endp";
		Pattern end_pattern = Pattern.compile(funEnd_regex);

		String entry_regex = "call " + "((?!loc_).)*$";
		Pattern function_pattern = Pattern.compile(entry_regex);
		
 		
		
		HashMap<String, ArrayList<String>> functionMap = new HashMap<String,ArrayList<String>>();
		HashMap<String, ArrayList<String>> functionMap1 = new HashMap<String,ArrayList<String>>();
					
		funQueue queue = new funQueue();
		funQueue queue1 = new funQueue();
					
		Graph graph1 = new Graph();
		Graph graph2 = new Graph();
				
		Scanner scanner =  new Scanner(new FileReader("C:\\Fall 2013\\CS 298\\MWOR assembly40\\MWOR after process\\MWOR_19.asm"));
		Scanner scanner1 = new Scanner(new FileReader("C:\\Fall 2013\\CS 298\\MWOR assembly40\\MWOR after process\\MWOR_19.asm"));
					
					/* This routine is to find out start and end of a function */
		malwareDetection.defineBoundry(scanner,start_pattern,end_pattern,function_pattern,functionMap,queue);
		malwareDetection.defineBoundry(scanner1,start_pattern,end_pattern,function_pattern,functionMap1,queue1);
					
		graph1= malwareDetection.createGraph(functionMap,queue,graph1);
		graph2= malwareDetection.createGraph(functionMap1,queue1,graph2);

		/*Retain Original Vertex List from both the graph*/
		ArrayList<Vertex> graph1List = graph1.vertexList;
		ArrayList<Vertex> graph2List = graph2.vertexList;
					
		malwareDetection.similarCheck(graph1,graph2,graph1List,graph2List);
					
	}

	private static void similarCheck(Graph graph1, Graph graph2, ArrayList<Vertex> graph1List, ArrayList<Vertex> graph2List) {
		
		ArrayList<Vertex> common_vertex1= new ArrayList<Vertex>();
		ArrayList<Vertex> common_vertex2= new ArrayList<Vertex>();
		externalFunSimilarCheck(graph1,graph2,common_vertex1,common_vertex2);
		
		int size= common_vertex1.size();
		double common_edge=0,common_vertex=0,max_vertex=0,graph1edge=0,graph2edge=0;
		double edge_sim = 0,vertex_sim=0;
		
		if(size>0)
		{	
			localFunSimilarCheck1(graph1,graph2,common_vertex1,common_vertex2);
		}	
		
		opcodeSimilarCheck(graph1,graph2,common_vertex1,common_vertex2);
		
		successorMatch(graph1,graph2,common_vertex1,common_vertex2,size);
		
		
		predecessorMatch(graph1,graph2,common_vertex1,common_vertex2,size);
		
		
		common_edge=commonEdge(graph1,graph2,common_vertex1,common_vertex2,size);
		
		for(Map.Entry<Vertex,LinkedList<Vertex>> entry: graph1.adjList.entrySet())
		{
			graph1edge = graph1edge + entry.getValue().size();
		}
		
		for(Map.Entry<Vertex,LinkedList<Vertex>> entry: graph2.adjList.entrySet())
		{
			graph2edge = graph2edge + entry.getValue().size();
		}
		
		
		
		common_vertex = common_vertex1.size();
		max_vertex = Math.max(graph1.adjList.size(), graph2.adjList.size());
		
		vertex_sim = (common_vertex/max_vertex);
		
		System.out.println(vertex_sim);
		

	}
	
	private static void externalFunSimilarCheck(Graph graph1, Graph graph2,
			ArrayList<Vertex> common_vertex1,ArrayList<Vertex> common_vertex2) 
	{
		int vertex_in_graph1 = 0, vertex_in_graph2=0;
		String funEnd_regex = "sub_(\\w)";
		Pattern end_pattern = Pattern.compile(funEnd_regex);
		int index=0;
		vertex_in_graph1 = graph1.vertexList.size();
		vertex_in_graph2 = graph2.vertexList.size();
			
			for(int i=0;i<vertex_in_graph2;i++)
			{
				Vertex temp = graph2.vertexList.get(i);
				Matcher match = end_pattern.matcher(temp.function_name);
				if(!match.find())
				{
					for(int j=0;j<vertex_in_graph1;j++)
					{
						if(temp.function_name.equals(graph1.vertexList.get(j).function_name))
						{
							common_vertex1.add(index, temp);
							common_vertex2.add(index,temp);
							index++;
							break;
						}
					}	
				}			
			}
		for(int i=0;i<common_vertex1.size();i++)
		{
			Vertex temp1= common_vertex1.get(i);
			for(int j=0;j<graph1.vertexList.size();j++)
			{
				if(graph1.vertexList.get(j).function_name.equals(temp1.function_name))
				{
					graph1.vertexList.remove(graph1.vertexList.get(j));	
					break;
				}
			}
		}
		
		for(int k=0;k<common_vertex2.size();k++)
		{	
			Vertex temp1= common_vertex2.get(k);
			for(int j=0;j<graph2.vertexList.size();j++)
			{
				if(graph2.vertexList.get(j).function_name.equals(temp1.function_name))
				{
					graph2.vertexList.remove(graph2.vertexList.get(j));
					break;
				}
			}		
		}
		}
	
	private static void localFunSimilarCheck1(Graph graph1, Graph graph2,
			ArrayList<Vertex> common_vertex1,ArrayList<Vertex> common_vertex2) 
	{	
		String funEnd_regex = "sub_(\\w)";
		Pattern end_pattern = Pattern.compile(funEnd_regex);
		int cur_index = common_vertex1.size();
		int cur_index1=cur_index;
		int vertex_graph2= graph2.vertexList.size();
		int vertex_graph1= graph1.vertexList.size();
		
		
		int i=0;
		for(;i<vertex_graph2;)
			{
				Vertex temp = graph2.vertexList.get(i);
				LinkedList<Vertex> list = graph2.adjList.get(temp);
				ArrayList<String> funNames = new ArrayList<String>();
				int index=0;
				for(int j=0;j<list.size();j++)
				{
					String fun = list.get(j).function_name;
					Matcher match = end_pattern.matcher(fun);
					if(!match.find())
					{
						funNames.add(index, fun);
						index++;
					}
				}
				if(funNames.size() < 2)
				{
					i++;
					continue;
				}
				else
				{
					int j=0;
					int flagi=0;
					for(;j<vertex_graph1;j++)
					{
						flagi=0;
						LinkedList<Vertex> list1= graph1.adjList.get(graph1.vertexList.get(j));
						ArrayList<String> funNames1 = new ArrayList<String>();
						int index1=0;
						for(int k=0;k<list1.size();k++)
						{
							String fun = list1.get(k).function_name;
							Matcher match = end_pattern.matcher(fun);
							if(!match.find())
							{
								funNames1.add(index1, fun);
								index1++;
							}
						}
						
						if(funNames1.size()<2)
						{
							continue;
						}
						else
						{
							int simCount=0;
							int l=0;
							
							int funNames1_size=funNames1.size(),funNames_size=funNames.size();
							for(;l<funNames_size;)
							{
								int m=0;
								int flagl=0;
								for(;m<funNames1_size;m++)
								{
									flagl=0;
									if(funNames.get(l).equals(funNames1.get(m)))
									{
										simCount++;
										funNames.remove(l);
										funNames1.remove(m);
										funNames1_size=funNames1.size();
										funNames_size=funNames.size();
										
										flagl=1;
										break;
									}
								}
								
								if(m==funNames1_size && flagl!=1)
								{
									
									l++;
								}		
							}
							if(simCount>=2)
							{
								common_vertex2.add((cur_index1),graph2.vertexList.get(i));
								common_vertex1.add((cur_index1),graph1.vertexList.get(j));
								graph2.vertexList.remove(i);
								graph1.vertexList.remove(j);
								vertex_graph1=graph1.vertexList.size();
								vertex_graph2=graph2.vertexList.size();
								cur_index1++;
								flagi=1;
								break;
							}
						}	
					}
					
					if(j==vertex_graph1 && flagi!=1)
					{
						
						i++;
					}	
				}
			}
		
	}	

	private static void opcodeSimilarCheck(Graph graph1, Graph graph2,
			ArrayList<Vertex> common_vertex1,ArrayList<Vertex> common_vertex2) 
	{	
		String funEnd_regex = "sub_(\\w)";
		Pattern end_pattern = Pattern.compile(funEnd_regex);
		int cur_index = common_vertex1.size();
		int cur_index1=cur_index;
		int vertex_graph2= graph2.vertexList.size();
		int vertex_graph1= graph1.vertexList.size();
		InstMap map = new InstMap();
		
		int i=0;
		for(;i<vertex_graph2;)
		{
			String fun = graph2.vertexList.get(i).function_name;
			Matcher match = end_pattern.matcher(fun);
			if(match.find())
			{
				Vertex temp = graph2.vertexList.get(i);
				double tempdegree = temp.indegree+temp.outdegree;
				ArrayList<String> opcode = temp.opcode_seq;
				int [] colVar = new int[15];
				int [] vector = new int[15];
				
				for(int j=0;j<opcode.size();j++)
				{
					String temp1=opcode.get(j);
					System.out.println(temp1);
					int inst_class=map.instMap.get(temp1);
					if(colVar[inst_class]!=1)
					{
						colVar[inst_class]=1;
					}
					vector[inst_class]++;	
				}
				
				int j=0;
				int flagi=0;
				for(;j<vertex_graph1;j++)
				{
					
					String fun1 = graph1.vertexList.get(j).function_name;
					Matcher match1 = end_pattern.matcher(fun1);
					if(match1.find())
					{						
						Vertex temp1= graph1.vertexList.get(j);
						double temp1degree = temp1.indegree+temp1.outdegree;
						ArrayList<String> opcode1= temp1.opcode_seq;
						int [] colVar1 = new int[15];
						int [] vector1 = new int[15];	
						int colVarCount=0,sumVectors=0,vectorsqaure=0,vector1square=0;
						
						double cosineSim=0,degreeSim=0,lenSim=0, alpha=0.98,beta=0.83,gamma=0.5;
						for(int k=0;k<opcode1.size();k++)
						{
							String temp2=opcode1.get(k);
							//System.out.println(temp2);
							int inst_class1=map.instMap.get(temp2);
							if(colVar1[inst_class1]!=1)
							{
								colVar1[inst_class1]=1;
							}
							vector1[inst_class1]++;
						}
					
						for(int l=0;l<colVar.length;l++)
						{
							if(colVar[l]==colVar1[l])
							{
								colVarCount++;
							}
							else
							{
								break;
							}
						}
					
							/*if color variable is same, calculate cosine similarity*/
						if(colVarCount==colVar.length)
						{
							for(int m=0;m<vector.length;m++)
							{
								sumVectors = sumVectors + (vector[m]*vector1[m]);
								vectorsqaure = vectorsqaure + (vector[m]*vector[m]);
								vector1square = vector1square + (vector1[m]*vector1[m]);	
							}
						
							cosineSim = (sumVectors)/((Math.sqrt(vectorsqaure)*Math.sqrt(vector1square)));
						}
							/*check next vertex for similar color variable*/
						else
						{
							continue;
						}	
					
						if(tempdegree==temp1degree)
						{
							degreeSim=1;
						}
					
						else
						{
							degreeSim = 1/(Math.abs(tempdegree-temp1degree));		
						}
				
						if(temp.length <= temp1.length)
						{
							lenSim = (temp.length)/(temp1.length);
						}
						else
						{
							lenSim = temp1.length/temp.length;
						}
				
						if(cosineSim >= alpha && lenSim >=beta && degreeSim >=gamma )
						{
							common_vertex2.add((cur_index1),temp);
							common_vertex1.add((cur_index1),temp1);
							graph2.vertexList.remove(i);
							graph1.vertexList.remove(j);
							vertex_graph1=graph1.vertexList.size();
							vertex_graph2=graph2.vertexList.size();
							cur_index1++;
							flagi=1;
							break;
						}
					}
				}
				if(j==vertex_graph1 && flagi!=1)
				{
					//System.out.println("here I is " +i);
					i++;
				}
			}
			else
			{
				i++;
			}
		}
	}

	private static void successorMatch(Graph graph1, Graph graph2,
			ArrayList<Vertex> common_vertex1, ArrayList<Vertex> common_vertex2,int size) 
	{		
		String funEnd_regex = "sub_(\\w)";
		Pattern end_pattern = Pattern.compile(funEnd_regex);
		queueExample queue1 = new queueExample();
		queueExample queue2 = new queueExample();
		int cur_index = common_vertex1.size();
		int cur_index1=cur_index;
		InstMap map = new InstMap();
		for(int i=size;i<common_vertex1.size();i++)
		{
			queue1.add(common_vertex1.get(i));
			queue2.add(common_vertex2.get(i));
		}
		
		while(!queue1.isEmpty())
		{
			Vertex v1= queue1.remove();
			Vertex v2= queue2.remove();
			
			LinkedList<Vertex> v1successor = new LinkedList<Vertex>();
			LinkedList<Vertex> v2successor = new LinkedList<Vertex>();
			
			ArrayList<Vertex> v1successorlist = new ArrayList<Vertex>();
			ArrayList<Vertex> v2successorlist = new ArrayList<Vertex>();
			
			for(int j=0;j<graph1.adjList.get(v1).size();j++)
			{
				v1successor.add(graph1.adjList.get(v1).get(j));
			}
			
			for(int k=0;k<v1successor.size();k++)
			{
				//String fun = graph1.vertexList.get(k).function_name;
				String fun = v1successor.get(k).function_name;
				Matcher match = end_pattern.matcher(fun);
				if(match.find())
				{
					for(int l=0;l<graph1.vertexList.size();l++)
					{
						if(v1successor.get(k).function_name.equals(graph1.vertexList.get(l).function_name))
						{
							v1successorlist.add(v1successor.get(k));
						}
					}
				}
			}
			
			for(int j=0;j<graph2.adjList.get(v2).size();j++)
			{
				v2successor.add(graph2.adjList.get(v2).get(j));
			}
			
			for(int k=0;k<v2successor.size();k++)
			{
				//String fun = graph2.vertexList.get(k).function_name;
				String fun = v2successor.get(k).function_name;
				Matcher match = end_pattern.matcher(fun);
				if(match.find())
				{
					for(int k1=0;k1<graph2.vertexList.size();k1++)
					{
						if(v2successor.get(k).function_name.equals(graph2.vertexList.get(k1).function_name))
						{
							v2successorlist.add(v2successor.get(k));
						}
					}
				}
			}
			int v1listSize = v1successorlist.size();
			int v2listSize = v2successorlist.size();
			int m=0;
			for(;m<v1listSize;)
			{
				int n=0;
				int flagi=0;
				//Vertex temp = graph1.vertexList.get(m);
				Vertex temp = v1successorlist.get(m);
				ArrayList<String> opcode = temp.opcode_seq;
				int [] vector = new int[15];
				for(int j=0;j<opcode.size();j++)
				{
					String temp1=opcode.get(j);
					//System.out.println(temp1);
					int inst_class=map.instMap.get(temp1);
					vector[inst_class]++;	
				}
						
				for(;n<v2listSize;n++)
				{
					//Vertex temp1= graph2.vertexList.get(n);
					flagi=0;
					Vertex temp1 = v2successorlist.get(n);
					ArrayList<String> opcode1= temp1.opcode_seq;
					int sumVectors=0,vectorsqaure=0,vector1square=0;
					int [] vector1 = new int[15];

					double cosineSim=0,/*delta=0.67*/ delta=0.97;
					for(int k=0;k<opcode1.size();k++)
					{
						String temp2=opcode1.get(k);
						//System.out.println(temp2);
						int inst_class1=map.instMap.get(temp2);
						vector1[inst_class1]++;
					}
					for(int j1=0;j1<vector.length;j1++)
					{
						sumVectors = sumVectors + (vector[j1]*vector1[j1]);
						vectorsqaure = vectorsqaure + (vector[j1]*vector[j1]);
						vector1square = vector1square + (vector1[j1]*vector1[j1]);	
					}

					cosineSim = (sumVectors)/((Math.sqrt(vectorsqaure)*Math.sqrt(vector1square)));	

					if(cosineSim >= delta)
					{
						common_vertex2.add((cur_index1),temp1);
						common_vertex1.add((cur_index1),temp);
						queue1.add(temp);
						queue2.add(temp1);
						graph1.vertexList.remove(temp);
						graph2.vertexList.remove(temp1);
						v1successorlist.remove(m);
						v2successorlist.remove(n);
						v1listSize = v1successorlist.size();
						v2listSize = v2successorlist.size();
						cur_index1++;
						flagi=1;
						break;
					}
				}
				
				if(n==v2listSize && flagi!=1)
					m++;
			}
		}
	}
	
	private static void predecessorMatch(Graph graph1, Graph graph2,
			ArrayList<Vertex> common_vertex1, ArrayList<Vertex> common_vertex2,
			int size) 
	{
		String funEnd_regex = "sub_(\\w)";
		Pattern end_pattern = Pattern.compile(funEnd_regex);
		queueExample queue1 = new queueExample();
		queueExample queue2 = new queueExample();
		int cur_index = common_vertex1.size();
		int cur_index1=cur_index;
		InstMap map = new InstMap();
		for(int i=size;i<common_vertex1.size();i++)
		{
			queue1.add(common_vertex1.get(i));
			queue2.add(common_vertex2.get(i));
		}
		
		while(!queue1.isEmpty())
		{
			Vertex v1= queue1.remove();
			Vertex v2= queue2.remove();
			
			LinkedList<Vertex> v1pre = new LinkedList<Vertex>();
			LinkedList<Vertex> v2pre = new LinkedList<Vertex>();
			
			ArrayList<Vertex> v1prelist = new ArrayList<Vertex>();
			ArrayList<Vertex> v2prelist = new ArrayList<Vertex>();
		
			for(int i=0;i<graph1.vertexList.size();i++)
			{
				Vertex v3= graph1.vertexList.get(i);
				String fun = v3.function_name;
				Matcher match = end_pattern.matcher(fun);
				if(match.find())
				{	
					v1pre = graph1.adjList.get(v3);
					for(int j=0;j<v1pre.size();j++)
					{
						if(v1pre.get(j).function_name.equals(v1.function_name))
						{
							//v1prelist.add(v1pre.get(j));
							v1prelist.add(v3);
						}
					}
				}	
			}
			
			for(int i=0;i<graph2.vertexList.size();i++)
			{
				Vertex v3= graph2.vertexList.get(i);
				String fun = v3.function_name;
				Matcher match = end_pattern.matcher(fun);
				if(match.find())
				{	
					v2pre = graph2.adjList.get(v3);
					for(int j=0;j<v2pre.size();j++)
					{
						if(v2pre.get(j).function_name.equals(v2.function_name))
						{
							//v2prelist.add(v2pre.get(j));
							v2prelist.add(v3);
						}
					}
				}
			}	
			
			int v1prelistSize = v1prelist.size();
			int v2prelistSize = v2prelist.size();
			int m=0;
			for(;m<v1prelistSize;)
			{
				int [] vector = new int[15];
				int n=0;
				int flagi=0;
				//Vertex temp = graph1.vertexList.get(m);
				Vertex temp = v1prelist.get(m);
				ArrayList<String> opcode = temp.opcode_seq;
				for(int j=0;j<opcode.size();j++)
				{
					String temp1=opcode.get(j);
					//System.out.println(temp1);
					int inst_class=map.instMap.get(temp1);
					vector[inst_class]++;	
				}
				
				for(;n<v2prelistSize;n++)
				{
					int [] vector1 = new int[15];
					flagi=0;
					//Vertex temp1= graph2.vertexList.get(n);
					Vertex temp1 = v2prelist.get(n);
					ArrayList<String> opcode1= temp1.opcode_seq;
					int sumVectors=0,vectorsqaure=0,vector1square=0;
					double cosineSim=0,/*delta=0.67*/delta=0.97;
					for(int k=0;k<opcode1.size();k++)
					{
						String temp2=opcode1.get(k);
						//System.out.println(temp2);
						int inst_class1=map.instMap.get(temp2);
						vector1[inst_class1]++;
					}
					for(int j1=0;j1<vector.length;j1++)
					{
						sumVectors = sumVectors + (vector[j1]*vector1[j1]);
						vectorsqaure = vectorsqaure + (vector[j1]*vector[j1]);
						vector1square = vector1square + (vector1[j1]*vector1[j1]);	
					}
						
					cosineSim = (sumVectors)/((Math.sqrt(vectorsqaure)*Math.sqrt(vector1square)));

					if(cosineSim >= delta)
					{
						common_vertex2.add((cur_index1),temp1);
						common_vertex1.add((cur_index1),temp);
						queue1.add(temp);
						queue2.add(temp1);
						graph1.vertexList.remove(temp);
						graph2.vertexList.remove(temp1);
						v1prelist.remove(m);
						v2prelist.remove(n);
						v1prelistSize = v1prelist.size();
						v2prelistSize = v2prelist.size();
						cur_index1++;
						flagi=1;
						break;						
					}
				}
				
				if(n==v2prelistSize && flagi!=1)
					m++;
			}
		}
	}

	private static int commonEdge(Graph graph1, Graph graph2,
			ArrayList<Vertex> common_vertex1, ArrayList<Vertex> common_vertex2,int size) 
	{
		int comm_edge=0;
		for(int i=size;i<common_vertex1.size();i++)
		{
			Vertex v1= common_vertex1.get(i);
			//System.out.println("I is:" +i);
			if(v1!=null)
			{
				Vertex v2=common_vertex2.get(i);
				if(v2!=null)
				{
					LinkedList<Vertex> list= graph1.adjList.get(v1);
					LinkedList<Vertex> list1=graph2.adjList.get(v2);
					//LinkedList<Vertex> copylist= list;
					//LinkedList<Vertex> copylist1= list1;
					LinkedList<Vertex> copylist = new LinkedList<Vertex>();
					LinkedList<Vertex> copylist1 = new LinkedList<Vertex>();
					for(int i1=0;i1<list.size();i1++)
						copylist.add(list.get(i1));
					for(int i2=0;i2<list1.size();i2++)
						copylist1.add(list1.get(i2));
					
					int j=0;
					int listSize = copylist.size();
					int list1Size =  copylist1.size();
					for(;j<listSize;)
					{
						int comm_vertex_found=0;
						int index=0;
						int l=0;
						int flagl=0;
						Vertex v3=copylist.get(j);
						for(int k=0;k<common_vertex1.size();k++)
						{
							if(common_vertex1.get(k).function_name.equals(v3.function_name))
							{	
								comm_vertex_found=1;
								index=k;
								break;
							}	
						}
						
						if(comm_vertex_found==1)
						{
							Vertex v4=common_vertex2.get(index);
							if(v4!=null)
							{
								for(;l<list1Size;l++)
								{
									flagl=0;
									Vertex v5= copylist1.get(l);
									if(v5.function_name.equals(v4.function_name))
									{
										comm_edge++;
										copylist.remove(j);
										copylist1.remove(l);
										listSize = copylist.size();
										list1Size = copylist1.size();
										flagl=1;
										break;
									}
								}
								
								if(l==list1Size && flagl!=1)
									j++;
							}
						}
						else
						{	
							j++;
						}
					}
				}
				else
				{
					continue;
				}
			}
		
			else
			{
				continue;
			}
		}
		
		return comm_edge;
	}

	private static void defineBoundry(Scanner scanner, Pattern start_pattern, Pattern end_pattern, Pattern function_pattern, HashMap<String,ArrayList<String>> functionMap, funQueue queue) 
	{
		while(scanner.hasNext())
		{
			ArrayList<String> functionDataBuffer = new ArrayList<String>();
			String currentLine1 = scanner.nextLine();
			Matcher start_matcher = start_pattern.matcher(currentLine1);
			/* This if match will identify start of subroutine in assembly code */
			if(start_matcher.find())
			{
				String [] array = start_matcher.group().split(" ");
				String currentLine = scanner.nextLine();
				functionDataBuffer.add(currentLine);
				Matcher end_matcher = end_pattern.matcher(currentLine);
				/*Here while loop print everything within subroutine until it reached end of 
				 * subroutine
				 */
				while(!end_matcher.find())
				{
					currentLine = scanner.nextLine();
					end_matcher = end_pattern.matcher(currentLine);
					/* This if identifies end of subroutine */
					if(end_matcher.find())
					{
						functionMap.put(array[0], functionDataBuffer);
						break;
					}
					else
					{
						functionDataBuffer.add(currentLine);
					}	
				}
			}
			else
			{
				Matcher function_matcher = function_pattern.matcher(currentLine1);
				boolean queueFlag=false;
				if(function_matcher.find())
				{
					String [] array = function_matcher.group().split(" ");
					for(int i=0;i<queue.length();i++)
					{
						if(queue.getQueue().get(i).equals(array[1]))
						{
							queueFlag=true;
							break;
						}
					}
					if(queueFlag==false)
						queue.insert(array[1]);
				}
			}
		}	
			
		for(Map.Entry<String, ArrayList<String>> entry:functionMap.entrySet())
		{
			String funName = entry.getKey();
			boolean isEntryFun = true;
			String instruction=null;
			String [] array = new String[2];
			for(Map.Entry<String, ArrayList<String>> entry1:functionMap.entrySet())
			{	
				if(!entry1.getKey().equals(funName))
				{
					ArrayList<String> funData = entry1.getValue();
					for(int i=0;i<funData.size();i++)
					{
						instruction = funData.get(i);
						array = instruction.split(" ");
						if(array[0].equals("call"))
						{
							if(array[1].equals(funName))
							{
								isEntryFun = false;
								break;
							}
						}
					}
					
					if(isEntryFun == false)
						break;	
				}
			}
			if(isEntryFun == true)
			{
				boolean queueFlag=false;
				for(int i=0;i<queue.length();i++)
				{
					if(queue.getQueue().get(i).equals(funName))
					{
						queueFlag=true;
						break;
					}
				}
				if(queueFlag==false)
					queue.insert(funName);
			}
		}		
	}
}
